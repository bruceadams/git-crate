#+TITLE:     Pallet Reference
#+AUTHOR:    Hugo Duncan
#+EMAIL:     hugo_duncan@yahoo.com
#+DATE:      2010-06-17 Thu
#+DESCRIPTION: Pallet is a node provisioning, configuration and administration tool.
#+KEYWORDS:
#+LANGUAGE:  en
#+OPTIONS:   H:3 num:t toc:t \n:nil @:t ::t |:t ^:t -:t f:t *:t <:t
#+OPTIONS:   TeX:t LaTeX:nil skip:nil d:nil todo:t pri:nil tags:not-in-toc
#+INFOJS_OPT: view:nil toc:nil ltoc:t mouse:underline buttons:0 path:http://orgmode.org/org-info.js
#+EXPORT_SELECT_TAGS: export
#+EXPORT_EXCLUDE_TAGS: noexport
#+LINK_UP: index.html
#+LINK_HOME: index.html
#+property: exports code
#+property: results output
#+property: cache true
#+STYLE: <link rel="stylesheet" type="text/css" href="doc.css" />

#+MACRO: clojure [[http://clojure.org][Clojure]]
#+MACRO: jclouds [[http://jclouds.org][jclouds]]

Pallet is a node provisioning, configuration and administration tool.  It is
written in {{{clojure}}}, and runs on the JVM.

* First Steps
** Overview

The simplest way to start pallet (but definitely not the nicest) is with a git
checkout of the source and maven (see below).

#+source: def-service
#+begin_src clojure :results silent :session s1
  (require 'pallet.maven)
  (require 'org.jclouds.compute)
  (def service
       (apply org.jclouds.compute/compute-service
        (concat (pallet.maven/credentials) [:log4j :enterprise :ssh])))
#+end_src



** Install

Pallet can be used in projects as a jar file.  It is available at [[http://clojars.org/pallet][Clojars]], and
can be used with maven, leiningen or any maven repository aware tool.

#+BEGIN_SRC clojure :session s1
  (def service
       (apply org.jclouds.compute/compute-service
        (concat (pallet.maven/credentials) [:log4j :enterprise :ssh])))
#+END_SRC



*** Source
Pallet is available on [[http://github.com/hugoduncan/pallet][github]]. Pallet requires [[http://clojure.org/][Clojure 1.2]], and uses [[http://github.com/jclouds/jclouds][JClouds]].

#+BEGIN_SRC sh :dir tmp
  git clone git://github.com/hugoduncan/pallet.git
#+END_SRC

You can start a REPL using maven.  At this time lein can not be used to start a
REPL.

#+BEGIN_SRC sh :dir tmp
  mvn clojure:repl
#+END_SRC

Using lein or maven you can also start a swank session, and connect to it with
Emacs, etc.

#+BEGIN_SRC sh
  mvn clojure:swank -Dmaven.test.skip=true
#+END_SRC

#+BEGIN_SRC sh
  lein swank
#+END_SRC





* Talking to the cloud

Pallet uses {{{jclouds}}} to create, start and stop nodes.  In order to use the cloud,
you will need to specify your cloud credentials.  Each cloud has a slightly
different terminology for the username/key and password/secret.

** Cloud Provider Names

In order to sign in to your cloud API, you will need to tell pallet the name of
your cloud.  The names pallet recognises can be displayed with the following:

#+BEGIN_SRC clojure  :session s1
   (require 'pallet.compute)
   (pallet.compute/supported-clouds)
#+END_SRC

** Explicit credentials

You can log in to the cloud explicitly

#+source: explicit-credentials(provider username password)
#+BEGIN_SRC clojure :session s1 :cache yes :results silent
  (require 'org.jclouds.compute)
  (defn service []
    (org.jclouds.compute/compute-service
     "provider" "username" "password" :log4j :enterprise :ssh))
#+END_SRC

** Credentials in settings.xml

Settings.xml is a maven file, often used to hold user specific configuration for
maven.  You can add your cloud provider information to this file, which is
normally located at [[file:~/.m2/settings.xml][~/.m2/settings.xml]].

#+BEGIN_SRC nxml
  <settings>
    <profiles>
      <profile>
        <id>terremark</id>
        <activation>
          <activeByDefault>true</activeByDefault>
        </activation>
        <properties>
          <pallet.service>Your Cloud serivce name</pallet.service>
          <pallet.user>Your Cloud API username or key</pallet.user>
          <pallet.key>Your Cloud API secret or password</pallet.key>
        </properties>
      </profile>
    </profiles>
  </settings>
#+END_SRC

You can then use this information with pallet:

#+BEGIN_SRC clojure  :session s1
  (require 'pallet.maven)
  (def service
       (apply org.jclouds.compute/compute-service
              (concat (pallet.maven/credentials) [:log4j :enterprise :ssh])))
#+END_SRC

* Talking to nodes
** The =admin= User

To SSH to a node, pallet requires a username and an SSH key.  These are read
from =pallet.utils/*admin-user*=, which defaults to your username, and =id_rsa=
identity.  You can rebind this using =pallet.core/with-admin-user=.

** Other SSH Key Strategies
While convenient, having all your nodes authorise the same SSH key is not the
best security practice.  Pallet allows you to install a middleware to provide an
identity using you own strategy, =pallet.core/with-node-execution-wrapper=. A
per node identity could be implemented using something like this:

#+BEGIN_SRC clojure  :session s1
  (require 'pallet.core)
  (require 'pallet.execute)
  (require 'clj-ssh.ssh)

  (defn lookup-identity [request]
    ;; Implement this to
    ;; return [private-key public-key passphrase]
    )

  (defn node-based-identity
   [handler]
   (fn [request]
    (binding [pallet.execute/default-agent-atom (atom nil)]
      (apply clj-ssh.ssh/add-identity
       (pallet.execute/default-agent)
       (lookup-identity))
      (handler request))))

  (pallet.core/with-node-execution-wrapper node-based-identity
    ;; perform some configuration actions
    ;; (lift ....)
    )
#+END_SRC

* Node Types
# <<node-types>>

In pallet, node types are defined with =defnode=.  The minimum requirement is
for a tag and an empty image template specification.

#+BEGIN_SRC clojure  :session s1
  (require 'pallet.core)
  (pallet.core/defnode mytag [])
#+END_SRC

An empty template specification implies a default image will be used for the
nodes, usually the latest Ubuntu version, or CentOS if no Ubuntu images are
available.

** Tags

In pallet, tags are used to identify identically configured machines.  The
=converge= command can be used to control the number of machines running with
each tag, allowing simple cluster management. Tag names may not contain hyphens.

Tags are used to select the nodes targeted by a =converge= or =lift= operation.

** Image Templates

The image used for a node can be specified by using JCloud's template
mechanism.  The image template in =defnode= is exactly as for jclouds clojure API.

#+BEGIN_SRC clojure  :session s1
  (require 'pallet.core)
  (pallet.core/defnode mytag [:centos :min-ram 512 :min-cores 4])
#+END_SRC

* Phases

A phase specifies a sequence of crates to be executed.  A phase can be defined
as part of a [[Node Type][node type]], or inline in a =configure= or =lift= invocation, using
the =phase= macro.

** :bootstrap

The =:bootstrap= phase is applied whenever pallet starts a new node.

** :configure

The =:configue= phase is applied by default by both the =converge= and the
=lift= commands.


* Operations
** Converge

The =converge= function can be used to adjust node counts and to apply phases.
The =:bootstrap= phase is the first phase applied to any new node that is
started, and =:configure= is always applied.  Additional phases may also be
specified. If the =:configure= phase is not explicitly passed, then it will
always be applied as the first phase (or second, after =:bootstrap= on new
nodes).

#+BEGIN_SRC clojure  :session s1
  (require 'pallet.core)
  (pallet.core/defnode mytag [])

  (defn scale-cluster [n]
    (pallet.core/converge {mytag n}))
#+END_SRC

=converge= also accepts a prefix, which is applied to the tags in the call.
This can be used to build job specific clusters.

#+BEGIN_SRC clojure  :session s1
  (require 'pallet.core)
  (require 'pallet.resource)
  (require 'pallet.crate.automated-admin-user)

  (defn my-bootstrap
    [request]
    (pallet.crate.automated-admin-user/automated-admin-user "user"))

  (pallet.core/defnode lb []
    :bootstrap (pallet.resource/phase my-bootstrap))
  (pallet.core/defnode webapp []
    :bootstrap (pallet.resource/phase my-bootstrap))
  (pallet.core/defnode db []
    :bootstrap (pallet.resource/phase my-bootstrap))

  (defn scale-cluster [prefix n]
    (pallet.core/converge prefix {lb 1 webapp n db (inc (/ n 2))}))
#+END_SRC

** Lift

The =lift= function is used to apply phases. The :configure phase is run by
default only if no phases are explicitly specified.

* Crates
Crates are functions that encapsulate some unit of configuration or
administration.  A crate must have a first =request= argument, and must
return an request map. The request can be threaded using clojure's =->=
macro. Crates can take other arguments as required.

** Composing existing crates
The simplest way of creating a crate is to compose it from existing crates.

#+BEGIN_SRC clojure  :session s1
  (require 'pallet.resource.package)
  (require 'pallet.crate.git)
  (require 'pallet.crate.tomcat)

  (defn my-simple-config
    [request]
    (-> request
      (pallet.resource.package/package "maven2")
      (pallet.crate.git/git)
      (pallet.crate.tomcat/tomcat)))
#+END_SRC

** Creating resources
=defresource= can be used to define crates that generate custom script..

** Aggregate resource

=defaggregate= can be used to define crates that collect parameters over
multiple invocations and emit a resource based on the aggregated parameters.
This is used in the sudoers crate, for example, to emit /etc/sudoers.

** Local resources
=deflocal= defines a crate that will be run on the local machine.

** Parameters
The request map contains a :parameters key, which is used by crates to communicate
configuration to each other.


