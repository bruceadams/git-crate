#+TITLE:     Pallet
#+AUTHOR:    Hugo Duncan
#+EMAIL:     hugo_duncan@yahoo.com
#+DATE:      2010-06-17 Thu
#+DESCRIPTION: Pallet is a node provisioning, configuration and administration tool.
#+KEYWORDS:
#+LANGUAGE:  en
#+OPTIONS:   H:3 num:t toc:t \n:nil @:t ::t |:t ^:t -:t f:t *:t <:t
#+OPTIONS:   TeX:t LaTeX:nil skip:nil d:nil todo:t pri:nil tags:not-in-toc
#+INFOJS_OPT: view:nil toc:nil ltoc:t mouse:underline buttons:0 path:http://orgmode.org/org-info.js
#+EXPORT_SELECT_TAGS: export
#+EXPORT_EXCLUDE_TAGS: noexport
#+LINK_UP:
#+LINK_HOME:
#+property: exports code
#+property: results output
#+property: cache true
#+STYLE: <link rel="stylesheet" type="text/css" href="doc.css" />

#+MACRO: clojure [[http://clojure.org][Clojure]]
#+MACRO: jclouds [[http://jclouds.org][jclouds]]

Pallet is a node provisioning, configuration and administration tool.  It is
written in {{{clojure}}}, and runs on the JVM.

* Overview

What makes pallet different to some of the other tools out there?

** Features
*** No Dependencies

The machines being managed require no special dependencies to be installed. As
long as they have bash and ssh running, they can be used with pallet.  For me
this was important - it means that you can use pretty much any image out there,
which is great for ad-hoc testing and development.

*** No Server

Pallet has no central server to set up and maintain - it simply runs on
demand. You can run it from anywhere, even over a remote REPL connection.

*** Everything in Version Control

In pallet, all your configuration is handled in SCM controlled files - there is
no database involved.  This means that your configuration can always be kept in
step with the development of your crates, and the versions of the external
crates that you use.

*** Jar File Distribution of Crates

Custom crates can be distributed as jar files, and so can be published in maven
repositories, and be consumed in a version controlled manner.  Hopefully this
will promote shared crates.

*** Provisioning, Configuration and Administration

Pallet aims quite wide. You can use it for starting an stopping nodes, for
configuring nodes, deploying projects and also for running administration tasks.
To be honest, this wasn't an initial design goal, but has come out of the wash
that way.

** How it works

Pallet is written in {{{clojure}}}, and so runs in a JVM.  You can embed it in any JVM
based project, or use it directly at the REPL.

Pallet talks to a cloud provider, in order to start up new nodes, etc.  It does
this using the excellent {{{jclouds}}} library.  Once the nodes are running,
Pallet uses SSH to communicate with the nodes.

To execute actions on the nodes, pallet executes shell scripts.  These scripts
are generated in {{{clojure}}}.  At the lowest level, Pallet embeds shell script
in {{{clojure}}}, and wraps shell script fragments into {{{clojure}}} functions,
creating reusable resources.

Of course, no two operating systems are identical, so Pallet allows dispatching
of the functions based on packager, etc, enabling abstraction of a node's
operating system.

Higher level "crates" are then put together, that use the resources to install
packages, etc. Crates can also be implemented using the same machinery as
resource functions.

[[Node Types][Node types]] are defined that specify a tag and the sequence of crates to apply
for each of a number of phases. By default, pallet defines =:bootstrap= and
=:configure= phases, but you can add as many phases as you like
(e.g. =:backup=).

Phases are executed using either the =converge= or =lift= commands, with
=converge= also adjusting the number of nodes running for each tag.


** Related Projects

*** Configuration
| Project Name | Link |
|-
| Chef | [[http://wiki.opscode.com/display/chef/Home]] |
| Puppet | [[http://www.puppetlabs.com/]] |
| cfengine | [[http://www.cfengine.org]] |

*** Node Provisioning
| Project Name | Link |
|-
| jClouds | [[http://www.jclouds.org/ ]] |
| fog | [[http://github.com/geemus/fog]] |

*** Application Services
| Project Name | Link |
|-
| Capistrano | |
| Fabric | |
| Func | |


If you have a project that you would like included above, I'll be happy to add it.

* First Steps
** Overview

The simplest way to start pallet (but definitely not the nicest) is with a git
checkout of the source and maven (see below).

#+source: def-service
#+begin_src clojure :results silent :session s1
  (require 'pallet.maven)
  (require 'org.jclouds.compute)
  (def service
       (apply org.jclouds.compute/compute-service
        (concat (pallet.maven/credentials) [:log4j :enterprise :ssh])))
#+end_src



** Install

Pallet can be used in projects as a jar file.  It is available at [[http://clojars.org/pallet][Clojars]], and
can be used with maven, leiningen or any maven repository aware tool.

#+BEGIN_SRC clojure :session s1
  (def service
       (apply org.jclouds.compute/compute-service
        (concat (pallet.maven/credentials) [:log4j :enterprise :ssh])))
#+END_SRC



*** Source
Pallet is available on [[http://github.com/hugoduncan/pallet][github]]. Pallet requires [[http://clojure.org/][Clojure 1.2]], and uses [[http://github.com/jclouds/jclouds][JClouds]].

#+BEGIN_SRC sh :dir tmp
  git clone git://github.com/hugoduncan/pallet.git
#+END_SRC

You can start a REPL using maven.  At this time lein can not be used to start a
REPL.

#+BEGIN_SRC sh :dir tmp
  mvn clojure:repl
#+END_SRC

Using lein or maven you can also start a swank session, and connect to it with
Emacs, etc.

#+BEGIN_SRC sh
  mvn clojure:swank -Dmaven.test.skip=true
#+END_SRC

#+BEGIN_SRC sh
  lein swank
#+END_SRC





* Talking to the cloud

Pallet uses {{{jclouds}}} to create, start and stop nodes.  In order to use the cloud,
you will need to specify your cloud credentials.  Each cloud has a slightly
different terminology for the username/key and password/secret.

** Cloud Provider Names

In order to sign in to your cloud API, you will need to tell pallet the name of
your cloud.  The names pallet recognises can be displayed with the following:

#+BEGIN_SRC clojure  :session s1
   (require 'pallet.compute)
   (pallet.compute/supported-clouds)
#+END_SRC

** Explicit credentials

You can log in to the cloud explicitly

#+source: explicit-credentials(provider username password)
#+BEGIN_SRC clojure :session s1 :cache yes :results silent
  (require 'org.jclouds.compute)
  (defn service []
    (org.jclouds.compute/compute-service
     "provider" "username" "password" :log4j :enterprise :ssh))
#+END_SRC

** Credentials in settings.xml

Settings.xml is a maven file, often used to hold user specific configuration for
maven.  You can add your cloud provider information to this file, which is
normally located at [[file:~/.m2/settings.xml][~/.m2/settings.xml]].

#+BEGIN_SRC nxml
  <settings>
    <profiles>
      <profile>
        <id>terremark</id>
        <activation>
          <activeByDefault>true</activeByDefault>
        </activation>
        <properties>
          <pallet.service>Your Cloud serivce name</pallet.service>
          <pallet.user>Your Cloud API username or key</pallet.user>
          <pallet.key>Your Cloud API secret or password</pallet.key>
        </properties>
      </profile>
    </profiles>
  </settings>
#+END_SRC

You can then use this information with pallet:

#+BEGIN_SRC clojure  :session s1
  (require 'pallet.maven)
  (def service
       (apply org.jclouds.compute/compute-service
              (concat (pallet.maven/credentials) [:log4j :enterprise :ssh])))
#+END_SRC

* Talking to nodes
** The =admin= User

To SSH to a node, pallet requires a username and an SSH key.  These are read
from =pallet.utils/*admin-user*=, which defaults to your username, and =id_rsa=
identity.  You can rebind this using =pallet.core/with-admin-user=.

** Other SSH Key Strategies
While convenient, having all your nodes authorise the same SSH key is not the
best security practice.  Pallet allows you to install a function to provide an
identity using you own strategy, =pallet.core/with-node-execution-wrapper=. A
per node identity could be implemented using something like this:

#+BEGIN_SRC clojure  :session s1
  (require 'pallet.utils)
  (require 'clj-ssh.ssh)

  (defn lookup-identity [node]
    ;; Implement this to
    ;; return [private-key public-key passphrase]
    )

  (defn node-based-identity
    [node user f]
    (binding [pallet.utils/default-agent-atom (atom nil)]
      (apply clj-ssh.ssh/add-identity
       (pallet.utils/default-agent)
       (lookup-identity))
      (f)))
#+END_SRC



* Node Types

In pallet, node types are defined with =defnode=.  The minimum requirement is
for a tag and an empty image template specification.

#+BEGIN_SRC clojure  :session s1
  (require 'pallet.core)
  (pallet.core/defnode mytag [])
#+END_SRC

An empty template specification implies a default image will be used for the
nodes, usually the latest Ubuntu version, or CentOS if no Ubuntu images are
available.

** Tags

In pallet, tags are used to identify identically configured machines.  The
=converge= command can be used to control the number of machines running with
each tag, allowing simple cluster management. Tag names may not contain hyphens.

Tags are used to select the nodes targeted by a =converge= or =lift= operation.

** Image Templates

The image used for a node can be specified by using JCloud's template
mechanism.  The image template in =defnode= is exactly as for jclouds clojure API.

* Phases

A phase specifies a sequence of crates to be executed.  A phase can be defined
as part of a [[Node Type][node type]], or inline in a =configure= or =lift= invocation, using
the =phase= macro.

** :bootstrap

The =:bootstrap= phase is applied whenever pallet starts a new node.

** :configure

The =:configue= phase is applied by default by both the =converge= and the
=lift= commands.


* Operations
** Converge

The =converge= function can be used to adjust node counts and to apply phases.
The =:bootstrap= phase is the first phase applied to any new node that is
started, and =:configure= is always applied.  Additional phases may also be
specified. If the =:configure= phase is not explicitly passed, then it will
always be applied as the first phase (or second, after =:bootstrap= on new
nodes).

#+BEGIN_SRC clojure  :session s1
  (require 'pallet.core)
  (pallet.core/defnode mytag [])

  (defn scale-cluster [n]
    (pallet.core/converge {mytag n}))
#+END_SRC

=converge= also accepts a prefix, which is applied to the tags in the call.
This can be used to build job specific clusters.

#+BEGIN_SRC clojure  :session s1
  (require 'pallet.core)
  (pallet.core/defnode lb [] :configure [])
  (pallet.core/defnode webapp [] :configure [])
  (pallet.core/defnode db [] :configure [])

  (defn scale-cluster [prefix n]
    (pallet.core/converge prefix {lb 1 webapp n db (inc (/ n 2))}))
#+END_SRC

** Lift

The =lift= function is used to apply phases. The :configure phase is run by
default only if no phases are explicitly specified.

* Crates
Crates are functions that encapsulate some unit of configuration or
administration. Crates can take arguments.

** Composing existing crates
The simplest way of creating a crate is to compose it from existing crates.

#+BEGIN_SRC clojure  :session s1
  (require 'pallet.resource.package)
  (require 'pallet.crate.git)
  (require 'pallet.crate.tomcat)

  (defn my-simple-config
    []
    (pallet.resource.package/package "maven2")
    (pallet.crate.git/git)
    (pallet.crate.tomcat/tomcat))
#+END_SRC

** Creating resources
=defresource= can be used to define crates that rely on node specific details.

** Aggregate resource

=defaggregate= can be used to define crates that collect parameters over
multiple invocations and emit a resource based on the aggregated parameters.
This is used in the sudoers crate, for example, to emit /etc/sudoers.

** Local resources
=deflocal= defines a crate that will be run on the local machine.
** Parameters
** Delayed Arguments
